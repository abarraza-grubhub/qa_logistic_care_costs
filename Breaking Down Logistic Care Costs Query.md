**A complete and updated version, with comments and images, can be found in Google Docs:
[here](https://docs.google.com/document/d/1O6tZxbNd6mV2a_-JMTF1q6qXiZMxvkdw3HEBPdSIkws/edit?usp=sharing).**

# **Breaking Down Logistic Care Costs Query**

Document Author: [Andrea Barraza](mailto:abarraza@grubhub.com)  
Team: Research and Experimentation (REX)  
Type of Document: RFC  
Last Update: Jun 2, 2025  
Project: [Automation of the Driver Pay Experiment Readout](https://docs.google.com/document/u/1/d/1ElWzi8vgWXAbiZDgYMAL5EgNOl8SRcWwdqKZiangovo/edit)

1. # Introduction

This is a RFC document created to align on the logic and interpretation of the [Logistic Care Costs](https://redash.gdp.data.grubhub.com/queries/234720/source?p_start%20date=2024-09-21&p_end%20date=2024-10-23#322400) query. It is intended to support async collaboration between the Experimentation Data Science (DS) team and Finance team. 

**Goals**

* Ensure the DS team is aligned with the stakeholder’s interpretation of what the query is doing.  
  * Provide a clear breakdown of the query’s components, inputs, and outputs to demonstrate alignment with its intended logic and structure.  
* Identify and address any open questions. Questions will be added as comments in the doc.  
* Document shared understanding as part of [Automation of the Driver Pay Experiment Readout](https://docs.google.com/document/u/1/d/1ElWzi8vgWXAbiZDgYMAL5EgNOl8SRcWwdqKZiangovo/edit) project.

**Secondary Goals:**

* The document can serve as a tool to help interpret and understand the query. Most sections are best read alongside the query, which provides helpful context and makes it easier to follow how each part fits together.

The methodology employed to put this document together is found in [Appendix A](#bookmark=id.6f1hmvzgkrjq).

2. # Query Goal and Context

This [SQL query](https://redash.gdp.data.grubhub.com/queries/234720/source?p_start%20date=2024-09-21&p_end%20date=2024-10-23#322400) is designed to calculate Fulfillment Care Costs (FCC) at Grubhub.

FCC specifically refers to expenses incurred due to issues caused directly from the order fulfillment process – from the moment an order is placed to when it reaches the diner's door. These encompass costs from customer care interactions, compensations such as refunds, and operational responses like redeliveries, all triggered by fulfillment problems, such as late deliveries, missing or incorrect items, or food quality issues upon arrival.

For context, FCC is a core performance indicator contributing to the calculation of Total Fulfillment Costs, a key business metric tracked by the company.

The primary financial metric this query computes is total\_care\_cost (more details in [Section 7](#bookmark=id.tz48ues0uvxb)). The query also categorizes these costs into key analytical groups, including the primary reasons for care incidents and specific market segments.

By leveraging this structured output, stakeholders can effectively analyze FCC patterns and trends. This enables comparisons across different dimensions—such as various markets, distinct timeframes, and specific care reason categories—to pinpoint areas for operational improvement. For instance, consistently high costs attributed to 'late delivery' reasons can highlight a need to investigate and optimize delivery speed or ETA accuracy.

3. # Query High-Level Logic

The query calculates Fulfillment Care Costs (FCC) by processing order-level data through several key tasks:

* **Identifies relevant orders** that experienced issues such as refunds, cancellations, guarantee claims, concessions, or customer contacts, using multiple data sources that include associated reasons.

* **Integrates data across all orders** (all GH delivered orders), combining delivery details (e.g., ETAs, actual delivery times, lateness flags, market segmentation) with associated care data and financial cost components.

* **Standardizes and categorizes issue reasons** using logic that consolidates raw reason fields into consistent fulfillment-related categories (e.g., 'late order', 'incorrect item'), which are later refined into broader analytical groups (e.g., 'logistics issues', 'transmission issues').

* **Calculates total\_care\_cost** by summing cost components tied to the identified issues, such as concessions, adjustments, and care ticket handling.

* **Aggregates results** by key dimensions like reason categories, market segment, and specific ETA-related flags, producing a summarized view of care costs for analysis and reporting.

Much of the query’s complexity lies in collecting care cost reasons from multiple sources and classifying them through this multi-step process, enabling clear attribution to fulfillment-related failures —such as logistics issues— versus other causes.

4. # CTE Description

The query is structured using multiple Common Table Expressions (CTEs) to break down the complex logic. Each CTE builds upon the previous ones or source tables to progressively refine the data and lead towards the final calculation of FCC.

The following table provides a brief summary of each CTE in the order of its appearance:

| CTE Name | Description |
| ----- | ----- |
| adj | Identifies orders with Grubhub-paid refunds (adjustments where direction \= 'ADJUST\_DOWN' and payer \= 'GRUBHUB').  This CTE focuses on the 'latest' adjustment for each order, determined by the record with the maximum adjustment\_timestamp\_utc. For this latest adjustment, it retrieves: The adjustment\_reason\_name, which is the formally recorded cause sourced from the adjustment record itself. The adj\_contact\_reason, sourced from an associated care ticket if one is linked to the adjustment. The adj\_contact\_reason reflects what was noted during the customer service contact, while the adjustment\_reason\_name is the official reason logged for the adjustment transaction itself. |
| ghg | Identifies orders with granted Grubhub Guarantee (GHG) claims (decision \= 'GRANT').  Based on the claim\_type, it then categorizes the claim's reason into the fg\_reason field as either 'Late Delivery \- GHG' or 'Price \- GHG' |
| care\_fg | Identifies orders that had concessions. For these orders, it populates the fg\_reason field with the latest customer contact reason associated with the concession(s), sourced from a linked care ticket. |
| diner\_ss\_cancels | Identifies orders with diner self-service cancellations. For each order, it selects a representative reason\_code and maps it to a descriptive diner\_ss\_cancel\_reason and a broader diner\_ss\_cancel\_reason\_group. |
| cancels | Identifies orders that have been cancelled, and retrieves key details like their cancellation time and status. For each order, it determines the cancel\_group and cancel\_reason\_name based on the primary cancellation data, diner self-service cancellation requests and any linked care tickets. If care tickets are linked, it also retrieves the primary (cancel\_pcr) and secondary (cancel\_scr) contact reasons, and then derives a single cancel\_contact\_reason based on those. |
| mdf | Retrieves detailed operational and contextual data for Grubhub-managed deliveries.  Among others, this data includes: Geographical information (like region and defined market segments). Comprehensive timestamp details, including raw local/UTC times and derived analytical date components (such as week, month, and day of the week). Key order attributes (e.g., bundle/future status, mealtime, delivery ETA type). From these details, it also calculates key estimated times of arrival (ETAs), cancellation indicators (cancel\_ind, cancel\_mins), and derives the primary delivery lateness indicator (ghd\_late\_ind). |
| contacts | Identifies orders that had a "worked" care contact (non-automated, cpo\_contact\_indicator \= 1). It retrieves the latest contact reason and provides a total count of such contacts for each order. |
| o | Performs several critical data integration and transformation functions: **Integrates Operational and Financial Data:** Joins operational event details from preceding CTEs (adjustments, cancellations, contacts, deliveries, etc.) with corresponding core financial data from order\_contribution\_profit\_fact. **Defines Analysis Scope:** Filters the dataset to include only GHD using managed\_delivery\_ind \= true. **Standardizes Issue Reasons:** Process and categorizes various raw input reasons related to adjustments, free grub, and associated contacts. This uses regexp\_like expressions for keyword and pattern matching, mapping these original reasons to a consistent set of predefined output categories for the adjustment\_reason\_name and fg\_reason fields.  Examples of these standardized categories include 'food temperature', 'incorrect order', 'late order', and 'missed delivery'.  This standardization supports later analysis of cost drivers and allows grouping into broader categories such as ‘Logistics Issues’. **Calculates Specific Costs:** Computes the cp\_care\_ticket\_cost by summing care ticket costs related to the diner, driver, restaurant, and internal GH support. **Derives Additional Key Indicators:** Calculates an expanded lateness indicator, ghd\_late\_ind\_incl\_cancel\_time, which also accounts for certain cancellations occurring after the estimated delivery time. Assigns fallback care\_cost\_reason and care\_cost\_group values by incorporating data from a separate reasons mapping table, based on the latest customer *contact* information. **Consolidates Data for Subsequent Processing:** Selects and passes through numerous financial components, enriched delivery details, the newly standardized reasons, and all calculated indicators. This comprehensive dataset is then used by subsequent CTEs for further refinement and the final calculation of total\_care\_cost. |
| o2 | Processes data directly from the o CTE, with its primary function being the creation of a consolidated adjustment\_and\_cancel\_reason\_combined field.  The value for this new field is the cancel\_reason\_name if present; otherwise, it defaults to the adjustment\_reason\_name. This establishes a single, primary reason for orders that might have both cancellation and adjustment data. Most, if not all, other columns from the o CTE are passed through unmodified. |
| o3 | Performs the final cost calculation and derives key analytical reason groupings, sourcing data from the preceding stage (o2): **Calculates total\_care\_cost**: More details in [Section 7](#bookmark=id.tz48ues0uvxb). **Defines Standardized Groups for Issue Reasons**: Derives adjustment\_group and fg\_group by classifying adjustment\_and\_cancel\_reason\_combined and fg\_reason, respectively, into predefined categories such as 'Logistics Issues', 'Restaurant Issues', or 'Diner Issues'. The mapping logic uses regexp\_like for keyword matching on the reason text and also leverages data from a cancellation reason map table. **Populates Missing fg\_reason:** Fills in missing fg\_reason values by using the main issue reason (adjustment\_and\_cancel\_reason\_combined) when a concession with a financial cost is present, ensuring concessions are still linked to a cause related to the overall order issue, rather than appearing without any explanation. **Consolidates Data for Final Aggregation**: It selects and passes through these newly calculated costs, derived groups, and refined reasons, along with numerous other data columns (dates, order attributes, other cost components, etc.) from the preceding stage. This comprehensive, order-level dataset is then used by the final SELECT statement for aggregation. |
| Final Select | The final SELECT takes the processed order-level data from the o3 CTE and summarizes it by first creating grouping dimensions, then calculating aggregated metrics for each group. It first defines key analytical dimensions—cany\_ind (market segment), care\_cost\_reason\_group (category for the care reason), and eta\_care\_reasons (ETA issue flag)—then calculates aggregated metrics for each combination, including total\_care\_cost. More details on the final output in [Section 8](#bookmark=id.dvarsg89u42r). |

5. # Data Sources Overview

**Unique Data Source Tables:**

* source\_cass\_rainbow\_data.adjustment\_reporting  
  * Contains records of order adjustments (e.g., partial refunds), including amounts, reasons, timestamps, and payer information.

* integrated\_core.ticket\_fact  
  * Stores information about customer care tickets, including creation dates, contact reasons, and associated order IDs.

* source\_zendesk\_ref.primary\_contact\_reason  
  * Reference table for primary contact reasons from Zendesk, mapping reason IDs to human-readable names.

* source\_zendesk\_ref.secondary\_contact\_reason  
  * Reference table for secondary contact reasons from Zendesk, mapping reason IDs to human-readable names.

* ods.carecontactfacade\_guarantee\_claim  
  * Contains data on Grubhub Guarantee (GHG) claims, including claim type, decision (e.g., granted/denied), and creation date.

* source\_cass\_rainbow\_data.concession\_reporting  
  * Records concessions (e.g., "Free Grub") issued, including associated order and ticket IDs, and relevant timestamps.

* ods.carereporting\_cancellation\_result  
  * Stores information about diner self-service cancellation attempts and the reasons provided by the diner.

* integrated\_order.order\_cancellation\_fact  
  * Fact table containing details about order cancellations, including primary cancellation reasons and associated ticket IDs.

* integrated\_ref.cancellation\_reason\_map  
  * Reference table mapping cancellation reason IDs to standardized cancellation groups and descriptive names.

* integrated\_delivery.managed\_delivery\_fact\_v2  
  * Comprehensive fact table with rich details for Grubhub-managed delivery orders (GHD).

* integrated\_order.order\_contribution\_profit\_fact  
  * Serves as the primary financial data source for orders. Supplies the cost components used for calculating Fulfillment Care Costs (FCC).  
    * Contains the financial values that quantify the monetary impact of operational events. For example, cp\_diner\_adj represents the value of diner adjustments. The specific events and their underlying reasons are identified in other tables and then linked to these financial values.

* csv\_sandbox.care\_cost\_reasons  
  * A custom mapping table, used to link specific contact reasons from tickets to standardized care cost reasons and groups.

| CTE Name | Data Sources (Tables and other CTEs) |
| ----- | ----- |
| adj | source\_cass\_rainbow\_data.adjustment\_reporting integrated\_core.ticket\_fact source\_zendesk\_ref.primary\_contact\_reason source\_zendesk\_ref.secondary\_contact\_reason |
| ghg | ods.carecontactfacade\_guarantee\_claim |
| care\_fg | source\_cass\_rainbow\_data.concession\_reporting integrated\_core.ticket\_fact source\_zendesk\_ref.primary\_contact\_reason source\_zendesk\_ref.secondary\_contact\_reason |
| diner\_ss\_cancels | ods.carereporting\_cancellation\_result |
| cancels | integrated\_order.order\_cancellation\_fact integrated\_ref.cancellation\_reason\_map integrated\_core.ticket\_fact source\_zendesk\_ref.primary\_contact\_reason source\_zendesk\_ref.secondary\_contact\_reason diner\_ss\_cancels (CTE)  |
| mdf | integrated\_delivery.managed\_delivery\_fact\_v2 |
| contacts | integrated\_core.ticket\_fact source\_zendesk\_ref.primary\_contact\_reason source\_zendesk\_ref.secondary\_contact\_reason |
| o | integrated\_order.order\_contribution\_profit\_fact mdf (CTE) cancels (CTE) adj (CTE) ghg (CTE) care\_fg (CTE) contacts (CTE) csv\_sandbox.care\_cost\_reasons |
| o2 | o (CTE)  |
| o3 | o2 (CTE) integrated\_ref.cancellation\_reason\_map |
| Final Select | o3 (CTE) |

See [Appendix C](#bookmark=id.cw22isy3d1vo) for details on how key fields from each data source are used in the query’s CTEs.

6. # Query Input Parameters: How Dates Are Used in CTEs

This query is designed to analyze fulfillment care costs over a specific period, which is determined by two input parameters: 

* {{start date}}: This is the first day of the period to analyze.  
* {{end date}}: This is the last day of the period to analyze.

To ensure all relevant information is captured, especially for events that might occur slightly before or after an order, the query often expands the {{start date}} and {{end date}} range by one day on `each` side. We call this the "**\+/- 1 Day Logic**". However, for some data, the exact dates are used.

The table below shows which data sources are filtered by date in each Common Table Expression (CTE) and how the date range is applied:

| CTE Name | Data Source Table Name | Date Column Used in Filter | \+/- 1 Day Logic Applied? |
| ----- | ----- | ----- | ----- |
| adj | source\_cass\_rainbow\_data.adjustment\_reporting | adjustment\_dt (parsed from string) | Yes |
| adj | integrated\_core.ticket\_fact | ticket\_created\_date | Yes |
| ghg | ods.carecontactfacade\_guarantee\_claim | created\_date | Yes |
| care\_fg | source\_cass\_rainbow\_data.concession\_reporting | expiration\_dt (parsed from string) | Yes |
| care\_fg | integrated\_core.ticket\_fact | ticket\_created\_date | Yes |
| diner\_ss\_cancels | ods.carereporting\_cancellation\_result | created\_date | Yes |
| cancels | integrated\_order.order\_cancellation\_fact | cancellation\_date | Yes |
| cancels | integrated\_ref.cancellation\_reason\_map | load\_date | Query is missing filtering by partition date (\*) |
| cancels | integrated\_core.ticket\_fact | ticket\_created\_date | Yes |
| mdf | integrated\_delivery.managed\_delivery\_fact\_v2 | business\_day | Yes |
| mdf | integrated\_delivery.managed\_delivery\_fact\_v2 | COALESCE(DATE(dropoff\_complete\_time\_local), DATE(eta\_at\_order\_placement\_time\_local), DATE(DATE\_ADD('hour',1,order\_created\_time\_local))) | No. Uses exact {{start date}} and {{end date}}. |
| contacts | integrated\_core.ticket\_fact | ticket\_created\_date | Yes |
| o | integrated\_order.order\_contribution\_profit\_fact | order\_date | Yes |
| o3 | integrated\_ref.cancellation\_reason\_map | load\_date | Query is missing filtering by partition date (\*) |
| (\*) Date filtering is likely omitted because the date a cancellation reason was added to the mapping table has no connection to the analysis time window. The goal is to match orders within the time window to all relevant cancellation reasons, regardless of when those reasons were added to the cancellation\_reason\_map. |  |  |  |

7. # Calculation of total\_care\_cost

The primary financial metric computed by this query is total\_care\_cost. This metric is designed to quantify the direct financial impact on Grubhub from care issues during the order fulfillment process. 

The total\_care\_cost is calculated at an order-level in the o3 CTE by summing five key financial components: cp\_care\_concession\_awarded\_amount, cp\_care\_ticket\_cost, cp\_diner\_adj, cp\_redelivery\_cost, and cp\_grub\_care\_refund. The calculation logic ensures that cp\_redelivery\_cost and cp\_grub\_care\_refund are treated as zero if they are originally null. These components are all mainly sourced from integrated\_order.order\_contribution\_profit\_fact in the o CTE.

The formula used is:

```sql
total_care_cost = cp_care_concession_awarded_amount
                  + cp_care_ticket_cost
                  + cp_diner_adj
                  + IF(cp_redelivery_cost IS NULL, 0, cp_redelivery_cost)
                  + IF(cp_grub_care_refund IS NULL, 0.00, cp_grub_care_refund)
```

Where:

* **cp\_care\_concession\_awarded\_amount**:   
* This represents the monetary value of concessions, such as "Free Grub" or other credits, awarded through customer care due to an issue with an order. 

* **cp\_care\_ticket\_cost**: Represents the calculated cost of handling a care ticket for an order, including factors like customer care agent time and related resources. It's derived in the o CTE by summing four distinct ticket cost components from the integrated\_order.order\_contribution\_profit\_fact table: cp\_diner\_care\_tickets \+ cp\_driver\_care\_tickets \+ cp\_restaurant\_care\_tickets \+ cp\_gh\_internal\_care\_tickets.

* **cp\_diner\_adj**: This value reflects direct financial adjustments made to a diner's order, commonly for issues like missing or incorrect items, or other partial refunds.

* IF(**cp\_redelivery\_cost** IS NULL, 0, cp\_redelivery\_cost): Represents the cost incurred by Grubhub if an order had to be redelivered to the customer.

* IF(**cp\_grub\_care\_refund** IS NULL, 0.00, cp\_grub\_care\_refund): This component accounts for specific refunds that are processed through care channels and are explicitly funded by Grubhub.

8. # Final Output Description

The final output of the query is an aggregated table that summarizes the order-level data from the o3 CTE (more on CTEs in [Section 4](#bookmark=id.d3laq9rtvd1t)). Including:

| Field | Description |
| :---- | :---- |
| **Grouping Dimensions** |  |
| cany\_ind | Categorizes orders into market segments ('CA', 'DCWP' \-specific NYC markets-, or 'ROM' \-Rest Of Markets-) using the CA\_Market and NYC\_Market fields from the input data. **Unique values:** 'CA', 'DCWP', or 'ROM' |
| care\_cost\_reason\_group | Assigns a single care cost reason group. This is determined through a hierarchical evaluation, first checking if total\_care\_cost is zero (for 'orders with no care cost'), then considering the adjustment\_group, fg\_group, and finally the care\_cost\_group fields. **Unique values:** 'orders with no care cost', 'logistics issues', 'transmission issues', 'other', 'not grouped', 'diner issues', 'restaurant issues'  |
| eta\_care\_reasons | Flags records as either 'ETA Issues' or 'Other' by checking for specific ETA-related keywords in the care reason fields. **Unique values:** 'ETA Issues', 'Other' |
| **Aggregated Metrics per Grouping Dimension** |  |
| orders | The total count of order records. |
| distinct\_order\_uuid | The count of unique orders. |
| total\_care\_cost | The sum of the total\_care\_cost values, representing the primary financial outcome. |
| ghd\_orders |  The count of orders identified as Grubhub Delivered. |
| orders\_with\_care\_cost | A specific count of orders where the sum of cp\_diner\_adj, cp\_care\_concession\_awarded\_amount, and cp\_care\_ticket\_cost is less than zero. |
| cancels\_osmf\_definition | The count of orders flagged as cancelled according to the order\_status\_cancel\_ind field. |

# Appendices

# Appendix A. Methodology

This report was created with support from **Gemini**. The process was as follows:

**1\. Query Formatting**

To make the SQL query easier to read and interpret, we used Gemini to reformat it while keeping the logic exactly the same. The formatted version can be found in [Appendix B](#bookmark=id.70yhrjpeqns4). To do this, we gave very specific instructions to ensure that the formatting didn’t change how the query works, and so that we could easily verify—using a Python script—that both versions are equivalent. This approach was necessary because Redash formatting wasn’t sufficient, and other formatting tools didn’t allow the same level of control.

**2\. First Version of Document**

We created a custom **Gem** in Gemini that included the context of the task, the goal of the document, the role of the LLM, and the SQL query itself. Using this setup, we collaborated with the Gem to define a rough outline and then developed each section through targeted conversations. For each section, we edited and formatted the content, reviewed the content by cross-checking with the query, internal documentation, and relevant Slack threads to make sure explanations were accurate, concise and clear.

*It’s worth noting that while an LLM was used to help generate this document, significant prompt engineering, tuning, and manual editing were required to shape the final version — it’s not a one-shot process where a single prompt delivers the re*sult.

**3\. Stakeholder Validation and Alignment**

After completing a first draft, the document was shared with stakeholders to confirm that it accurately reflects the logic of the query and the approach used to calculate FCC. The document was then updated to correct any inaccuracies or unclear explanations. This step ensured alignment across teams and increased confidence in the clarity and accuracy of the documentation.

# Appendix B. Fulfillment Care Cost Query

Formatted query [here](https://redash.gdp.data.grubhub.com/queries/242944/source?p_start%20date=2024-09-21&p_end%20date=2024-10-23#333217).

|  WITH adj AS (    SELECT        ar.order\_uuid        ,MAX\_BY(reason, adjustment\_timestamp\_utc) adjustment\_reason\_name \-- latest adjustment (on the off chance that there are multiple, won't duplicate order count when joining to order\_fact/profit\_fact)        ,MAX\_BY(COALESCE(sr.name, pr.name), adjustment\_timestamp\_utc) adj\_contact\_reason    FROM        source\_cass\_rainbow\_data.adjustment\_reporting ar    LEFT JOIN        integrated\_core.ticket\_fact tf        ON tf.ticket\_id \= ar.ticket\_id        AND tf.ticket\_created\_Date BETWEEN DATE\_ADD('day', \-1, *DATE* '{{start date}}') AND DATE\_ADD('day', 1, *DATE* '{{end date}}')    LEFT JOIN        source\_zendesk\_ref.primary\_contact\_reason pr        ON pr.contact\_reason\_id \= tf.primary\_contact\_reason    LEFT JOIN        source\_zendesk\_ref.secondary\_contact\_reason sr        ON sr.contact\_reason\_id \= tf.secondary\_contact\_reason    WHERE        *DATE*(DATE\_PARSE(CAST(adjustment\_dt AS *VARCHAR*), '%Y%m%d')) BETWEEN DATE\_ADD('day', \-1, *DATE* '{{start date}}') AND DATE\_ADD('day', 1, *DATE* '{{end date}}')        AND direction \= 'ADJUST\_DOWN' \-- refund        AND payer \= 'GRUBHUB' \-- paid by grubhub    GROUP BY        1 ), ghg AS (    SELECT        cart\_uuid order\_uuid        ,MAX(            CASE                WHEN claim\_type \= 'SERVICE' THEN 'Late Delivery \- GHG'                WHEN claim\_type \= 'PRICING' THEN 'Price \- GHG'            END        ) AS fg\_reason    FROM        ods.carecontactfacade\_guarantee\_claim    WHERE        created\_date BETWEEN DATE\_ADD('day', \-1, *DATE* '{{start date}}') AND DATE\_ADD('day', 1, *DATE* '{{end date}}')        AND decision \= 'GRANT'    GROUP BY        1 ), care\_fg AS (    SELECT        cr.order\_uuid        ,MAX\_BY(COALESCE(sr.name, pr.name), issue\_timestamp\_utc) fg\_reason    FROM        source\_cass\_rainbow\_data.concession\_reporting cr    LEFT JOIN        integrated\_core.ticket\_fact tf        ON tf.ticket\_id \= cr.ticket\_id        AND tf.ticket\_created\_Date BETWEEN DATE\_ADD('day', \-1, *DATE* '{{start date}}') AND DATE\_ADD('day', 1, *DATE* '{{end date}}')    LEFT JOIN        source\_zendesk\_ref.primary\_contact\_reason pr        ON pr.contact\_reason\_id \= tf.primary\_contact\_reason    LEFT JOIN        source\_zendesk\_ref.secondary\_contact\_reason sr        ON sr.contact\_reason\_id \= tf.secondary\_contact\_reason    WHERE        *DATE*(DATE\_PARSE(CAST(expiration\_dt AS *VARCHAR*), '%Y%m%d')) BETWEEN DATE\_ADD('day', \-1, *DATE* '{{start date}}') AND DATE\_ADD('day', 1, *DATE* '{{end date}}')    GROUP BY        1 ), diner\_ss\_cancels AS (    SELECT        order\_id order\_uuid        ,MAX(reason\_code) reason\_code        ,MAX(            CASE                WHEN reason\_code \= 'DINER\_PAYMENT\_ISSUE' THEN 'Payment Issues'                WHEN reason\_code \= 'DINER\_CHOSE\_WRONG\_ADDRESS' THEN 'Delivery Information Incorrect'                WHEN reason\_code \= 'DINER\_CHOSE\_WRONG\_ORDER\_ITEMS' THEN 'Ordered By Mistake'                WHEN reason\_code \= 'DINER\_DOES\_NOT\_WANT\_LATE\_ORDER' THEN 'Late Order'                WHEN reason\_code \= 'DINER\_DOES\_NOT\_WANT\_THE\_FOOD' THEN 'Change of Plans'            END        ) AS diner\_ss\_cancel\_reason        ,MAX(            CASE                WHEN reason\_code \= 'DINER\_PAYMENT\_ISSUE' THEN 'Diner Issues'                WHEN reason\_code \= 'DINER\_CHOSE\_WRONG\_ADDRESS' THEN 'Diner Issues'                WHEN reason\_code \= 'DINER\_CHOSE\_WRONG\_ORDER\_ITEMS' THEN 'Diner Issues'                WHEN reason\_code \= 'DINER\_DOES\_NOT\_WANT\_LATE\_ORDER' THEN 'Logistics Issues'                WHEN reason\_code \= 'DINER\_DOES\_NOT\_WANT\_THE\_FOOD' THEN 'Diner Issues'            END        ) AS diner\_ss\_cancel\_reason\_group    FROM        ods.carereporting\_cancellation\_result    WHERE        created\_date BETWEEN DATE\_ADD('day', \-1, *DATE* '{{start date}}') AND DATE\_ADD('day', 1, *DATE* '{{end date}}')    GROUP BY        1 ), cancels AS (    SELECT        ocf.order\_uuid        ,order\_status\_cancel\_ind        ,CASE            WHEN cancel\_group \= 'Not Mapped' AND diner\_ss\_cancel\_reason\_group IS NOT NULL THEN diner\_ss\_cancel\_reason\_group            WHEN LOWER(order\_status\_cancel\_reason) LIKE '%restaurant did%nt receive%' THEN 'Transmission Issues'            ELSE cancel\_group        END cancel\_group        ,CASE            WHEN cancel\_reason\_name \= 'Not Mapped' AND diner\_ss\_cancel\_reason IS NOT NULL THEN diner\_ss\_cancel\_reason            WHEN LOWER(order\_status\_cancel\_reason) LIKE '%restaurant did%nt receive%' THEN 'restaurant did not receive order'            ELSE cancel\_reason\_name        END AS cancel\_reason\_name        ,pr.name cancel\_pcr        ,sr.name cancel\_scr        ,COALESCE(cancellation\_time\_utc, tf.created\_time) cancel\_time\_utc        ,COALESCE(sr.name, pr.name) cancel\_contact\_reason    FROM        integrated\_order.order\_cancellation\_fact ocf    LEFT JOIN        integrated\_ref.cancellation\_reason\_map crm        ON CAST(crm.cancel\_reason\_id AS *VARCHAR*) \= CAST(ocf.primary\_cancel\_reason\_id AS *VARCHAR*)    LEFT JOIN        integrated\_core.ticket\_fact tf        ON tf.ticket\_id \= CAST(ocf.cancellation\_ticket\_id AS *BIGINT*)        AND tf.ticket\_created\_Date BETWEEN DATE\_ADD('day', \-1, *DATE* '{{start date}}') AND DATE\_ADD('day', 1, *DATE* '{{end date}}')    LEFT JOIN        source\_zendesk\_ref.primary\_contact\_reason pr        ON pr.contact\_reason\_id \= tf.primary\_contact\_reason    LEFT JOIN        source\_zendesk\_ref.secondary\_contact\_reason sr        ON sr.contact\_reason\_id \= tf.secondary\_contact\_reason    LEFT JOIN        diner\_ss\_cancels ccr        ON ccr.order\_uuid \= ocf.order\_uuid    WHERE        cancellation\_date BETWEEN DATE\_ADD('day', \-1, *DATE* '{{start date}}') AND DATE\_ADD('day', 1, *DATE* '{{end date}}') ), mdf AS (    SELECT        mdf.order\_uuid        ,mdf.region\_uuid        ,mdf.region\_name        ,mealtime        ,delivery\_eta\_type        \--- test regions vs control here        \---add testing date cohorts based on date2 column        ,CASE WHEN mdf.region\_name LIKE 'CA%' THEN 'CA' ELSE 'xCA' END CA\_Market        ,CASE            WHEN mdf.region\_uuid IN (                '92ecc187-d0ed-4b17-bcdb-7da84786f0ef',                '71ba188f-e632-4e6c-8710-fa1b6b7a303e',                'eea72701-225b-4f8c-a13d-b10798e7c89c',                'd56fcd88-9b3f-47f9-a7a9-ac8cc8b15e89',                '2c2aed8b-9f85-4666-873a-10f492b69dcb',                'adad9d37-7a3b-46ab-9ca6-c0a354b107d6',                'ac195f13-5f83-473e-b897-8c098c302699',                'a213d9d3-78ac-4025-a9d3-6a00304f344c',                'b2070f16-6d97-4c6e-9ce8-7ae581b4e87f',                'f373b4d7-9e3e-4960-bd54-9122c51fc02f',                '5d35d88c-fa24-488e-892c-b046ccfb9f61',                '7bf6fde8-d453-4679-83bb-c67b737f12ed',                '60fa2685-2463-48ba-b864-05384504ec2b',                '504eb68a-9148-4b1f-bcff-941a7ba8f0e1',                'a15298e0-4a9f-4f7d-aee5-507b7ed81651',                'f138e5e9-d03e-4832-8f60-6eda4246c1aa',                'afa226a3-f2e2-4d9b-8fa1-e228b8c7ed0d'            ) THEN 'DCWP'            ELSE 'xDCWP'        END NYC\_Market        ,IF(mdf.bundle\_type IS NOT NULL, TRUE, FALSE) bundle\_ind        ,IF(mdf.future\_order\_ind, TRUE, FALSE) AS future        ,*DATE*(DATE\_TRUNC('week', COALESCE(mdf.dropoff\_complete\_time\_local, mdf.eta\_at\_order\_placement\_time\_local, DATE\_ADD('hour', 1, mdf.order\_created\_time\_local)))) AS start\_of\_week        ,*DATE*(COALESCE(mdf.dropoff\_complete\_time\_local, mdf.eta\_at\_order\_placement\_time\_local, DATE\_ADD('hour', 1, mdf.order\_created\_time\_local))) AS date2        ,WEEK(COALESCE(mdf.dropoff\_complete\_time\_local, mdf.eta\_at\_order\_placement\_time\_local, DATE\_ADD('hour', 1, mdf.order\_created\_time\_local))) AS week        ,MONTH(COALESCE(mdf.dropoff\_complete\_time\_local, mdf.eta\_at\_order\_placement\_time\_local, DATE\_ADD('hour', 1, mdf.order\_created\_time\_local))) AS month        ,COALESCE(mdf.dropoff\_complete\_time\_utc, mdf.eta\_at\_order\_placement\_time\_utc, DATE\_ADD('hour', 1, mdf.order\_created\_time\_utc)) AS deliverytime\_utc        ,FORMAT\_DATETIME(COALESCE(mdf.dropoff\_complete\_time\_local, mdf.eta\_at\_order\_placement\_time\_local, DATE\_ADD('hour', 1, mdf.order\_created\_time\_local)), 'E') AS dayofweek        ,COALESCE(dropoff\_complete\_time\_local, eta\_at\_order\_placement\_time\_local, DATE\_ADD('hour', 1, order\_created\_time\_local)) AS datetime\_local        ,DATE\_DIFF('second', IF(future\_order\_ind IS NULL OR future\_order\_ind \= FALSE, mdf.order\_created\_time\_utc, mdf.delivery\_created\_time\_utc), lower\_bound\_eta\_at\_order\_placement\_time\_utc) / 60.0 AS diner\_ty\_eta        ,mdf.dropoff\_complete\_time\_utc dropoff\_complete\_time\_utc        ,mdf.eta\_at\_order\_placement\_time\_utc \+ INTERVAL '10' MINUTE ghd\_eta\_utc        ,CASE WHEN DATE\_DIFF('minute', mdf.eta\_at\_order\_placement\_time\_utc \+ INTERVAL '10' MINUTE, mdf.dropoff\_complete\_time\_utc) \> 0 THEN 1 ELSE 0 END ghd\_late\_ind        ,CASE WHEN cancelled\_time\_local IS NOT NULL THEN 1 ELSE 0 END AS cancel\_ind        ,CASE WHEN cancelled\_time\_local IS NOT NULL THEN DATE\_DIFF('second', click\_start\_time\_local, cancelled\_time\_local) / 60.0 ELSE NULL END AS cancel\_mins    FROM        integrated\_delivery.managed\_delivery\_fact\_v2 mdf    WHERE        mdf.business\_day BETWEEN DATE\_ADD('day', \-1, *DATE* '{{start date}}') AND DATE\_ADD('day', 1, *DATE* '{{end date}}')        AND COALESCE(*DATE*(mdf.dropoff\_complete\_time\_local), *DATE*(mdf.eta\_at\_order\_placement\_time\_local), *DATE*(DATE\_ADD('hour', 1, mdf.order\_created\_time\_local))) BETWEEN *DATE* '{{start date}}' AND *DATE* '{{end date}}' ), contacts AS (    SELECT        order\_uuid        ,MAX\_BY(ticket\_id, created\_time) AS latest\_ticket\_id        ,MAX\_BY(COALESCE(sr.name, pr.name), created\_time) AS latest\_contact\_reason        ,COUNT(ticket\_id) contacts    FROM        integrated\_core.ticket\_fact tf    LEFT JOIN        source\_zendesk\_ref.primary\_contact\_reason pr        ON pr.contact\_reason\_id \= tf.primary\_contact\_reason    LEFT JOIN        source\_zendesk\_ref.secondary\_contact\_reason sr        ON sr.contact\_reason\_id \= tf.secondary\_contact\_reason    WHERE        ticket\_created\_date BETWEEN DATE\_ADD('day', \-1, *DATE* '{{start date}}') AND DATE\_ADD('day', 1, *DATE* '{{end date}}')        AND ticket\_created\_date \< CURRENT\_DATE        AND order\_uuid IS NOT NULL        AND cpo\_contact\_indicator \= 1 \-- care worked contacts (automated contacts do not have a ticket cost)    GROUP BY        1 ), o AS (    SELECT        *DATE*(cpf.delivery\_time\_ct) date1        ,region\_uuid        ,region\_name        ,CA\_Market        ,NYC\_Market        ,diner\_ty\_eta        ,delivery\_eta\_type        ,mealtime        ,month        ,start\_of\_week        ,week        ,date2        ,deliverytime\_utc        ,dayofweek        ,datetime\_local        ,CAST(CONCAT(CAST(HOUR(datetime\_local) AS *VARCHAR*), ':', CAST(MINUTE(datetime\_local) AS *VARCHAR*)) AS *TIME*) AS time\_local        ,IF(cpf.managed\_delivery\_ind \= TRUE, 'ghd', 'non-ghd') ghd\_ind        ,cpf.order\_uuid        ,cp\_diner\_adj        ,cancel\_ind        ,cancel\_mins        ,COALESCE(c.order\_status\_cancel\_ind, FALSE) order\_status\_cancel\_ind        ,IF(c.order\_uuid IS NOT NULL, TRUE, FALSE) cancel\_fact\_ind        ,cancel\_group        ,cancel\_reason\_name        ,cancel\_contact\_reason        ,COALESCE(ghd\_late\_ind, 0) ghd\_late\_ind        ,CASE            WHEN ghd\_late\_ind \= 1 THEN 1            WHEN cancel\_time\_utc \> ghd\_eta\_utc AND dropoff\_complete\_time\_utc IS NULL THEN 1            ELSE 0        END ghd\_late\_ind\_incl\_cancel\_time \-- cancelled, no dropoff complete time        ,CASE            WHEN REGEXP\_LIKE(LOWER(adjustment\_reason\_name), 'food temp|cold|quality\_temp|temperature') THEN 'food temperature'            WHEN REGEXP\_LIKE(LOWER(adjustment\_reason\_name), 'incorrect order|incorrect item|wrong order|incorrect\_item') THEN 'incorrect order'            WHEN REGEXP\_LIKE(LOWER(adjustment\_reason\_name), 'damaged') THEN 'food damaged'            WHEN REGEXP\_LIKE(LOWER(adjustment\_reason\_name), 'missing') THEN 'missing item'            WHEN REGEXP\_LIKE(LOWER(adjustment\_reason\_name), 'item removed') THEN 'item removed from order'            WHEN REGEXP\_LIKE(LOWER(adjustment\_reason\_name), 'late') THEN 'late order'            WHEN REGEXP\_LIKE(LOWER(adjustment\_reason\_name), 'menu error') THEN 'order or menu issue'            WHEN REGEXP\_LIKE(LOWER(adjustment\_reason\_name), 'temporarily unavailable|unavailable') THEN 'out of item'            WHEN REGEXP\_LIKE(LOWER(adjustment\_reason\_name), 'order not rec|missed delivery') THEN 'missed delivery'            WHEN REGEXP\_LIKE(LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason)), 'food temp|cold|quality\_temp|temperature') THEN 'food temperature'            WHEN REGEXP\_LIKE(LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason)), 'incorrect order|incorrect item|wrong order|incorrect\_item') THEN 'incorrect order'            WHEN REGEXP\_LIKE(LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason)), 'damaged') THEN 'food damaged'            WHEN REGEXP\_LIKE(LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason)), 'missing') THEN 'missing item'            WHEN REGEXP\_LIKE(LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason)), 'item removed') THEN 'item removed from order'            WHEN REGEXP\_LIKE(LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason)), 'late') THEN 'late order'            WHEN REGEXP\_LIKE(LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason)), 'menu error') THEN 'order or menu issue'            WHEN REGEXP\_LIKE(LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason)), 'temporarily unavailable|unavailable') THEN 'out of item'            WHEN REGEXP\_LIKE(LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason)), 'order not rec|missed delivery') THEN 'missed delivery'            WHEN REGEXP\_LIKE(LOWER(adjustment\_reason\_name), 'refund due to|refund for') THEN LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason, adjustment\_reason\_name))            WHEN REGEXP\_LIKE(LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason)), 'refund due to|refund for') THEN LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason, adjustment\_reason\_name))            ELSE LOWER(COALESCE(cancel\_contact\_reason, adj\_contact\_reason, adjustment\_reason\_name)) \-- use contact reason when there's a long reason (refund due to item 1 item 2 etc)        END adjustment\_reason\_name        ,adj\_contact\_reason        ,driver\_pay\_per\_order        ,tip        ,bundle\_ind        ,CASE            WHEN cp\_care\_concession\_awarded\_amount \= 0 THEN NULL \-- no fg in profit fact            WHEN REGEXP\_LIKE(LOWER(COALESCE(ghg.fg\_reason, care\_fg.fg\_reason)), 'food temp|cold|quality\_temp|temperature') THEN 'food temperature'            WHEN REGEXP\_LIKE(LOWER(COALESCE(ghg.fg\_reason, care\_fg.fg\_reason)), 'incorrect order|incorrect item|wrong order|incorrect\_item') THEN 'incorrect order'            WHEN REGEXP\_LIKE(LOWER(COALESCE(ghg.fg\_reason, care\_fg.fg\_reason)), 'damaged') THEN 'food damaged'            WHEN REGEXP\_LIKE(LOWER(COALESCE(ghg.fg\_reason, care\_fg.fg\_reason)), 'missing') THEN 'missing item'            WHEN REGEXP\_LIKE(LOWER(COALESCE(ghg.fg\_reason, care\_fg.fg\_reason)), 'item removed') THEN 'item removed from order'            WHEN REGEXP\_LIKE(LOWER(COALESCE(ghg.fg\_reason, care\_fg.fg\_reason)), 'late') THEN 'late order'            WHEN REGEXP\_LIKE(LOWER(COALESCE(ghg.fg\_reason, care\_fg.fg\_reason)), 'menu error') THEN 'order or menu issue'            WHEN REGEXP\_LIKE(LOWER(COALESCE(ghg.fg\_reason, care\_fg.fg\_reason)), 'temporarily unavailable|unavailable') THEN 'out of item'            WHEN REGEXP\_LIKE(LOWER(COALESCE(ghg.fg\_reason, care\_fg.fg\_reason)), 'order not rec|missed delivery') THEN 'missed delivery'            \-- WHEN REGEXP\_LIKE(LOWER(adjustment\_reason\_name),'refund due to|refund for') THEN LOWER(COALESCE(cancel\_contact\_reason,adj\_contact\_reason,adjustment\_reason\_name))            \-- WHEN REGEXP\_LIKE(LOWER(COALESCE(cancel\_contact\_reason,adj\_contact\_reason)),'refund due to|refund for') THEN LOWER(COALESCE(cancel\_contact\_reason,adj\_contact\_reason,adjustment\_reason\_name))            ELSE LOWER(COALESCE(ghg.fg\_reason, care\_fg.fg\_reason))        END AS fg\_reason        ,ccr.care\_cost\_reason \-- excludes contact reasons where we typically give refunds/freegrub, as reasons will be captured by fg reason and adj reason logic. If we change the logic, use contacts.latest\_contact\_reason        ,COALESCE(ccr.care\_cost\_group, 'not grouped') care\_cost\_group \-- excludes contact reasons where we typically give refunds/freegrub, as reasons will be captured by fg reason and adj reason logic        ,cp\_care\_concession\_awarded\_amount        ,cp\_grub\_care\_refund        ,cp\_redelivery\_cost        ,cp\_diner\_care\_tickets \+ cp\_driver\_care\_tickets \+ cp\_restaurant\_care\_tickets \+ cp\_gh\_internal\_care\_tickets cp\_care\_ticket\_cost    FROM        integrated\_order.order\_contribution\_profit\_fact cpf    \-- LEFT JOIN integrated\_order.order\_cancellation\_fact ocf ON ocf.order\_uuid \= cpf.order\_uuid AND ocf.cancellation\_date BETWEEN DATE\_ADD('day',-1,DATE '{{start date}}') AND DATE\_ADD('day',1,DATE '{{end date}}')    JOIN        mdf        ON mdf.order\_uuid \= cpf.order\_uuid    LEFT JOIN        cancels c        ON c.order\_uuid \= cpf.order\_uuid    LEFT JOIN        adj        ON adj.order\_uuid \= cpf.order\_uuid    LEFT JOIN        ghg        ON ghg.order\_uuid \= cpf.order\_uuid    LEFT JOIN        care\_fg        ON care\_fg.order\_uuid \= cpf.order\_uuid    LEFT JOIN        contacts        ON contacts.order\_uuid \= cpf.order\_uuid    LEFT JOIN        csv\_sandbox.care\_cost\_reasons ccr        ON ccr.scr \= contacts.latest\_contact\_reason    WHERE        cpf.order\_date BETWEEN DATE\_ADD('day', \-1, *DATE* '{{start date}}') AND DATE\_ADD('day', 1, *DATE* '{{end date}}')        AND managed\_delivery\_ind \= TRUE        \--AND DATE(cpf.delivery\_time\_utc) BETWEEN DATE\_ADD('day',-1,DATE '{{start date}}') AND DATE\_ADD('day',1,DATE '{{end date}}')        \-- AND cp\_diner\_adj \< 0 \-- diner adjustment issued ), o2 AS (    SELECT        \-- ,eta\_min\_groupings        date1        ,region\_uuid        ,region\_name        ,CA\_Market        ,NYC\_Market        ,diner\_ty\_eta        ,delivery\_eta\_type        ,mealtime        ,month        ,start\_of\_week        ,week        ,date2        ,deliverytime\_utc        ,dayofweek        ,datetime\_local        ,time\_local        ,ghd\_ind        ,cancel\_ind        ,cancel\_mins        ,order\_uuid        ,cp\_diner\_adj        ,cp\_redelivery\_cost        ,order\_status\_cancel\_ind        ,cancel\_fact\_ind        ,cancel\_group        ,cancel\_reason\_name        ,cancel\_contact\_reason        ,ghd\_late\_ind        ,ghd\_late\_ind\_incl\_cancel\_time        ,CASE            WHEN cancel\_reason\_name \= 'Not Mapped' THEN adjustment\_reason\_name            WHEN cancel\_reason\_name IS NULL THEN adjustment\_reason\_name            ELSE LOWER(cancel\_reason\_name)        END adjustment\_and\_cancel\_reason\_combined        ,fg\_reason        ,cp\_care\_concession\_awarded\_amount        ,driver\_pay\_per\_order        ,tip        ,bundle\_ind        ,cp\_care\_ticket\_cost        ,cp\_grub\_care\_refund        ,care\_cost\_reason        ,care\_cost\_group    FROM        o ), o3 AS (    SELECT        date1        \-- ,eta\_min\_groupings        ,region\_uuid        ,region\_name        ,CA\_Market        ,NYC\_Market        ,diner\_ty\_eta        ,delivery\_eta\_type        ,month        ,mealtime        ,start\_of\_week        ,week        ,date2        ,deliverytime\_utc        ,dayofweek        ,datetime\_local        ,time\_local        ,ghd\_ind        ,order\_uuid        ,cp\_diner\_adj        ,cancel\_ind        ,cancel\_mins        ,cp\_care\_concession\_awarded\_amount \+ cp\_care\_ticket\_cost \+ cp\_diner\_adj \+ IF(cp\_redelivery\_cost IS NULL, 0, cp\_redelivery\_cost) \+ IF(cp\_grub\_care\_refund IS NULL, 0.00, cp\_grub\_care\_refund) total\_care\_cost        ,IF(cp\_redelivery\_cost IS NULL, 0, cp\_redelivery\_cost) AS cp\_redelivery\_cost        ,order\_status\_cancel\_ind        ,cancel\_fact\_ind        ,o2.cancel\_group        ,o2.cancel\_reason\_name        ,cancel\_contact\_reason        ,ghd\_late\_ind        ,ghd\_late\_ind\_incl\_cancel\_time        ,CASE            WHEN o2.cancel\_group IS NOT NULL AND o2.cancel\_group \!= 'Other' THEN crm.cancel\_group            WHEN REGEXP\_LIKE(LOWER(adjustment\_and\_cancel\_reason\_combined), 'missed delivery|order not rec|late|damaged|ghd driver|food temp|quality\_temp|cold') THEN 'Logistics Issues'            WHEN REGEXP\_LIKE(LOWER(adjustment\_and\_cancel\_reason\_combined), 'missing item|missing|incorrect\_order|menu error|incorrect\_item|missing\_item|incorrect item|incorrect order|quality|special|problem with food|food poison|object in food|temporarily unavailable|out of item|item removed|foreign object') THEN 'Restaurant Issues'            WHEN REGEXP\_LIKE(LOWER(adjustment\_and\_cancel\_reason\_combined), 'diner error|switch to delivery or pickup|change of plans') THEN 'Diner Issues'            ELSE COALESCE(crm.cancel\_group, 'not grouped')        END adjustment\_group        ,CASE            WHEN o2.cancel\_group IS NOT NULL AND o2.cancel\_group \!= 'Other' THEN crm.cancel\_group            WHEN REGEXP\_LIKE(LOWER(fg\_reason), 'missed delivery|order not rec|late|damaged|ghd driver|food temp|quality\_temp|cold') THEN 'Logistics Issues'            WHEN REGEXP\_LIKE(LOWER(fg\_reason), 'missing item|missing|incorrect\_order|menu error|incorrect\_item|missing\_item|incorrect item|incorrect order|quality|special|problem with food|food poison|object in food|temporarily unavailable|out of item|item removed|foreign object') THEN 'Restaurant Issues'            WHEN REGEXP\_LIKE(LOWER(fg\_reason), 'diner error|switch to delivery or pickup|change of plans') THEN 'Diner Issues'            ELSE COALESCE(crm.cancel\_group, 'not grouped')        END fg\_group        ,CASE            WHEN cp\_care\_concession\_awarded\_amount \< 0 AND fg\_reason IS NULL THEN adjustment\_and\_cancel\_reason\_combined            ELSE fg\_reason        END AS fg\_reason        ,cp\_care\_concession\_awarded\_amount        ,adjustment\_and\_cancel\_reason\_combined        ,driver\_pay\_per\_order        ,tip        ,bundle\_ind        ,cp\_care\_ticket\_cost        ,care\_cost\_reason        ,care\_cost\_group    FROM        o2    LEFT JOIN        integrated\_ref.cancellation\_reason\_map crm        ON LOWER(crm.cancel\_reason\_name) \= LOWER(o2.adjustment\_and\_cancel\_reason\_combined) ) SELECT    \* FROM    (        SELECT            CASE                WHEN CA\_Market \= 'CA' THEN CA\_Market                WHEN NYC\_Market \= 'DCWP' THEN NYC\_Market                ELSE 'ROM'            END AS cany\_ind            ,LOWER(                CASE                    WHEN total\_care\_cost \= 0 THEN 'orders with no care cost' \-- orders with no care cost                    WHEN adjustment\_group \!= 'not grouped' THEN adjustment\_group                    WHEN fg\_group \!= 'not grouped' THEN fg\_group                    WHEN care\_cost\_group \!= 'not grouped' THEN care\_cost\_group                    ELSE 'not grouped'                END            ) care\_cost\_reason\_group            ,CASE                WHEN LOWER(COALESCE(adjustment\_and\_cancel\_reason\_combined, fg\_reason, care\_cost\_reason)) IN (                    'order eta update',                    'delivery estimate confirmation',                    'diner requested cancel \- order too late',                    'late delivery',                    'late order',                    'delivery estimate confirmation',                    'order eta update',                    'delivery estimate confirmation'                ) THEN 'ETA Issues'                ELSE 'Other'            END AS eta\_care\_reasons            ,COUNT(o3.order\_uuid) orders            ,COUNT(DISTINCT order\_uuid) AS distinct\_order\_uuid            ,SUM(total\_care\_cost) AS total\_care\_cost            ,SUM(IF(ghd\_ind \= 'ghd', 1, 0)) ghd\_orders            ,SUM(IF((cp\_diner\_adj \+ cp\_care\_concession\_awarded\_amount \+ cp\_care\_ticket\_cost) \< 0, 1, 0)) orders\_with\_care\_cost            ,COUNT(                CASE                    WHEN o3.order\_status\_cancel\_ind \= TRUE THEN o3.order\_uuid                END            ) cancels\_osmf\_definition        FROM            o3        GROUP BY            1,            2,            3    ) LIMIT 10 |
| :---- |

# Appendix C. Data Sources and Key Fields

Reading the table alongside the query makes it easier to interpret.

| CTE Name | Data Source Table Name | Key Fields Used | Brief Description |
| ----- | ----- | ----- | ----- |
| adj | source\_cass\_rainbow\_data.adjustment\_reporting ar | order\_uuid reason adjustment\_timestamp\_utc ticket\_id adjustment\_dt direction payer | \- Provides order adjustment details.  \- Used to filter for Grubhub-paid refunds (direction \= 'ADJUST\_DOWN', payer \= 'GRUBHUB').  \- Identifies the latest adjustment reason (adjustment\_reason\_name) for an order in the off chance there are multiple reasons. |
| adj | integrated\_core.ticket\_fact tf | ticket\_id ticket\_created\_date primary\_contact\_reason secondary\_contact\_reason | \- Links adjustments to tickets via ticket\_id.  \- Fetches primary\_contact\_reason and secondary\_contact\_reason IDs associated with the adjustment. \- Filtered by ticket\_created\_date around the analysis period.  |
| adj | source\_zendesk\_ref.primary\_contact\_reason pr | contact\_reason\_id name | \- Provides the textual name for the primary contact reason associated with a ticket. \- Maps tf.primary\_contact\_reason ID with pr.contact\_reason\_id. \- The pr.name (reason description) is then used as a fallback in COALESCE(sr.name, pr.name) to determine the adj\_contact\_reason for an order, based on the latest adjustment.  |
| adj | source\_zendesk\_ref.secondary\_contact\_reason sr | contact\_reason\_id name | \- Provides the textual name for the secondary contact reason associated with a ticket. \- Maps tr.secondary\_contact\_reason ID with sr.contact\_reason\_id. \- The name is coalesced with pr.name to determine the adj\_contact\_reason.  |
| ghg | ods.carecontactfacade\_guarantee\_claim | cart\_uuid (as order\_uuid) claim\_type created\_date decision | \- Provides Grubhub Guarantee (GHG) claim data. \- Filters for granted claims (decision \= 'GRANT') within the specified created\_date range.  \- Categorizes the fg\_reason as 'Late Delivery \- GHG' or 'Price \- GHG' based on claim\_type.  |
| care\_fg | source\_cass\_rainbow\_data.concession\_reporting cr | order\_uuid ticket\_id issue\_timestamp\_utc expiration\_dt | \- Provides data on concessions (e.g., free grub).  \- Filters concessions based on expiration\_dt within the analysis period. \- Identifies the latest concession for an order using max\_by on issue\_timestamp\_utc.  |
| care\_fg | integrated\_core.ticket\_fact tf | ticket\_id ticket\_created\_date primary\_contact\_reason secondary\_contact\_reason | \- Links concessions to tickets via ticket\_id.  \- Fetches primary\_contact\_reason and secondary\_contact\_reason IDs associated with the concession. \- Filtered by ticket\_created\_date.  |
| care\_fg | source\_zendesk\_ref.primary\_contact\_reason pr | contact\_reason\_id name | \- Maps primary\_contact\_reason ID to its name.  |
| care\_fg | source\_zendesk\_ref.secondary\_contact\_reason sr | contact\_reason\_id name | \- Maps secondary\_contact\_reason ID to its name. \- The [sr.name](http://sr.name) is coalesced with pr.name to determine the latest fg\_reason (free grub reason). |
| diner\_ss\_cancels | ods.carereporting\_cancellation\_result | order\_id (as order\_uuid) reason\_code created\_date | \- Provides data on diner self-service cancellations. \- Filters cancellations by created\_date.  \- Maps reason\_code to a diner\_ss\_cancel\_reason (e.g., 'Payment Issues', 'Late Order').  \- Maps reason\_code to a broader diner\_ss\_cancel\_reason\_group (e.g., 'Diner Issues', 'Logistics Issues').  |
| cancels | integrated\_order.order\_cancellation\_fact ocf | order\_uuid order\_status\_cancel\_ind primary\_cancel\_reason\_id cancellation\_ticket\_id cancellation\_date cancellation\_time\_utc order\_status\_cancel\_reason | \- Core source for order cancellation data. \- Provides order\_status\_cancel\_ind, primary\_cancel\_reason\_id, and cancellation\_ticket\_id.  \- Filters cancellations by cancellation\_date. \- The text field order\_status\_cancel\_reason is used specifically to identify "Transmission Issues", i.e., when the restaurant did not receive the order. |
| cancels | integrated\_ref.cancellation\_reason\_map crm | cancel\_reason\_id cancel\_group cancel\_reason\_name | \- It’s used to map the ocf.primary\_cancel\_reason\_id to a standardized cancel\_group and cancel\_reason\_name.  |
| cancels | integrated\_core.ticket\_fact tf | ticket\_id ticket\_created\_date primary\_contact\_reason secondary\_contact\_reason  created\_time | \- Links cancellation tickets (ocf.cancellation\_ticket\_id) to get associated contact reasons.  \- created\_time is used in COALESCE for cancel\_time\_utc. \- Filtered by ticket\_created\_date.  |
| cancels | source\_zendesk\_ref.primary\_contact\_reason pr | contact\_reason\_id name | \- Provides the name for tf.primary\_contact\_reason(cancel\_pcr) associated with cancellation tickets.  |
| cancels | source\_zendesk\_ref.secondary\_contact\_reason sr | contact\_reason\_id name | \- Provides the name for tf.secondary\_contact\_reason(cancel\_scr).  \- The s[r.name](http://pr.name) is coalesced with pr.name to create cancel\_contact\_reason with the latest contact reason. |
| cancels | diner\_ss\_cancels ccr (CTE) | order\_uuid  diner\_ss\_cancel\_reason\_group  diner\_ss\_cancel\_reason | \- Augments cancellation data with self-service cancellation reasons.  \- If cancel\_group or cancel\_reason\_name from crm is 'Not Mapped', values from diner\_ss\_cancels are used.  |
| mdf | integrated\_delivery.managed\_delivery\_fact\_v2 mdf | order\_uuid region\_uuid region\_name mealtime delivery\_eta\_type bundle\_type future\_order\_ind dropoff\_complete\_time\_local eta\_at\_order\_placement\_time\_local order\_created\_time\_local dropoff\_complete\_time\_utc  eta\_at\_order\_placement\_time\_utc order\_created\_time\_utc delivery\_created\_time\_utc lower\_bound\_eta\_at\_order\_placement\_time\_utc cancelled\_time\_local  click\_start\_time\_local business\_day | \- Provides detailed information for managed delivery orders.  \- Used to extract regional data (region\_name, CA\_Market, NYC\_Market).  \- Derives various time-based features (e.g., start\_of\_week, date2, week, month, dayofweek, deliverytime\_utc).  \- Calculates diner expected ETA (diner\_ty\_eta).  \- Determines Grubhub delivery lateness (ghd\_late\_ind) based on ETA and actual dropoff.  \- Identifies cancelled orders (cancel\_ind) and minutes to cancel (cancel\_mins).  \- Filters orders based on business\_day and a coalesced delivery/ETA date falling within the {{start date}} and {{end date}}. |
| contacts | integrated\_core.ticket\_fact tf | order\_uuid ticket\_id created\_time primary\_contact\_reason secondary\_contact\_reason ticket\_created\_date cpo\_contact\_indicator | \- Source for customer care ticket information. \- Identifies the latest\_contact\_reason for an order using max\_by on created\_time.  \- Counts the number of contacts (tickets) per order. \- Filters for care-worked contacts (cpo\_contact\_indicator \= 1) as automated contacts do not have a ticket cost. \- Filters by ticket\_created\_date. |
| contacts | source\_zendesk\_ref.primary\_contact\_reason pr | contact\_reason\_id name | \- Maps primary\_contact\_reason ID to its name.  |
| contacts | source\_zendesk\_ref.secondary\_contact\_reason sr | contact\_reason\_id name | \- Maps secondary\_contact\_reason ID to its name.  \- The [sr.name](http://sr.name) is coalesced with pr.name to determine the latest\_contact\_reason.  |
| o | integrated\_order.order\_contribution\_profit\_fact cpf | delivery\_time\_ct order\_uuid managed\_delivery\_ind cp\_diner\_adj driver\_pay\_per\_order tip cp\_care\_concession\_awarded\_amount cp\_grub\_care\_refund cp\_redelivery\_cost cp\_diner\_care\_tickets cp\_driver\_care\_tickets cp\_restaurant\_care\_tickets cp\_gh\_internal\_care\_tickets order\_date | \- Primary fact table for order-level financial and cost data.  \- Supplies key cost components like cp\_diner\_adj, cp\_care\_concession\_awarded\_amount, cp\_grub\_care\_refund, cp\_redelivery\_cost, and various ticket costs.  \- Filters for managed delivery orders (managed\_delivery\_ind \= true) within the order\_date range.  |
| o | mdf (CTE) | Identifier for Join:  order\_uuid  Regional/Market Attributes:  region\_uuid region\_name CA\_Market NYC\_Market  Order Characteristics: delivery\_eta\_type mealtime bundle\_ind  Date/Time Attributes: month start\_of\_week week date2 deliverytime\_utc  dayofweek datetime\_local (used by o to derive o.time\_local ) ETA/Lateness Metrics: diner\_ty\_eta ghd\_late\_ind (coalesced to 0 in o if null )  ghd\_eta\_utc (used in o's ghd\_late\_ind\_incl\_cancel\_time calculation )  dropoff\_complete\_time\_utc (used in o's ghd\_late\_ind\_incl\_cancel\_time calculation )  Cancellation Metrics:  cancel\_ind  cancel\_mins | \- Joined on order\_uuid. Enriches order data with delivery details, regional flags, ETA information, time features, cancellation status, lateness flags, and bundle indicators.  |
| o | cancels c (CTE) | order\_uuid order\_status\_cancel\_ind cancel\_group cancel\_reason\_name cancel\_time\_utc cancel\_contact\_reason  | \- Joined on order\_uuid. Adds cancellation details like status, group, reason, contact reason, and UTC cancellation time (used for ghd\_late\_ind\_incl\_cancel\_time calculation).  |
| o | adj (CTE) | order\_uuid adjustment\_reason\_name  adj\_contact\_reason | \- Joined on order\_uuid. Provides adjustment reasons.  \- These are used in a complex CASE statement with regexp\_like to derive a standardized adjustment\_reason\_name, also considering cancel\_contact\_reason and adj\_contact\_reason.  |
| o | ghg (CTE) | order\_uuid fg\_reason | \- Joined on order\_uuid. Provides Grubhub Guarantee claim reasons.  |
| o | care\_fg (CTE) | order\_uuid fg\_reason | \- Joined on order\_uuid. Provides concession-based "free grub" reasons.  \- Coalesced with ghg.fg\_reason and then standardized using regexp\_like to determine the final fg\_reason in this CTE.  |
| o | contacts (CTE) | order\_uuid latest\_contact\_reason | \- Joined on order\_uuid. Provides latest\_contact\_reason from care tickets.  \- This is used as the join key to csv\_sandbox.care\_cost\_reasons. |
| o | csv\_sandbox.care\_cost\_reasons ccr | scr (maps to contacts.latest\_contact\_reason) care\_cost\_reason care\_cost\_group | \- Joined on ccr.scr \= contacts.latest\_contact\_reason.  \- Maps specific secondary contact reasons to a standardized care\_cost\_reason and care\_cost\_group. \- Acts as a fallback for reason assignment if not captured by adjustment or "free grub" reason logic.  |
| o2 | o (CTE) | All fields from o, including cancel\_reason\_name, adjustment\_reason\_name | \- Primarily a pass-through CTE that selects most fields from o.  \- Creates adjustment\_and\_cancel\_reason\_combined by coalescing cancel\_reason\_name (if not 'Not Mapped' or null) and adjustment\_reason\_name.  |
| o3 | o2 (CTE) | All fields from o2 are passed through or used. Key inputs from o2 include: Cost components: cp\_care\_concession\_awarded\_amount cp\_care\_ticket\_cost cp\_diner\_adj cp\_redelivery\_cost cp\_grub\_care\_refund Care reason fields: cancel\_group adjustment\_and\_cancel\_reason\_combined fg\_reason | \- Builds upon o2 by selecting most of its columns and applying further financial calculations and reason categorizations. \- Calculates total\_care\_cost by summing various cost fields.  \- Standardizes cp\_redelivery\_cost (null to 0).  \- To determine adjustment\_group and fg\_group, the query first attempts to use existing standardized categories from o2.cancel\_group (via the crm lookup table \- more in row below). If a category isn't immediately found, it then analyzes the detailed text of o2.adjustment\_and\_cancel\_reason\_combined or o2.fg\_reason using pattern matching (regexp\_like), with the crm table also providing fallback categories. \- Further refines fg\_reason based on cp\_care\_concession\_awarded\_amount and adjustment\_and\_cancel\_reason\_combined. |
| o3 | integrated\_ref.cancellation\_reason\_map crm | cancel\_reason\_name cancel\_group | \- Joined on lower(crm.cancel\_reason\_name) \= lower(o2.adjustment\_and\_cancel\_reason\_combined).  \- Provides crm.cancel\_group which is used in the logic for adjustment\_group and fg\_group within this CTE, especially if o2.cancel\_group is not 'Other' or as a general fallback.  |
| Final Select | o3 | For Deriving Grouping Dimensions:  To create cany\_ind: CA\_Market NYC\_Market To determine care\_cost\_reason\_group: total\_care\_cost (for 'orders with no care cost' logic) adjustment\_group fg\_group care\_cost\_group To determine eta\_care\_reasons: adjustment\_and\_cancel\_reason\_combined fg\_reason care\_cost\_reason For Aggregations:  order\_uuid (for counts)  total\_care\_cost (for sum) ghd\_ind (to count GHD orders) To count orders with care cost: cp\_diner\_adj cp\_care\_concession\_awarded\_amount cp\_care\_ticket\_cost order\_status\_cancel\_ind (to count cancellations)  | This final block aggregates the detailed, order-level data from the o3 CTE to produce a summarized report of care cost metrics.  It calculates several key metrics: total orders, distinct orders, sum of total care costs, count of GHD orders, count of orders with any care costs, and count of specific cancellations.  These metrics are grouped by:  1\. cany\_ind: A derived market segment (e.g., CA, NYC, or Rest of Markets).  2\. care\_cost\_reason\_group: A high-level categorization of care cost reasons.  3\. eta\_care\_reasons: A flag for issues related to ETA. |

